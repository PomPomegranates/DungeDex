@page "/dungemon/{Id:int}"
@rendermode @(new InteractiveWebAssemblyRenderMode(false))

@using System.Security.Claims
@using System.Net

@inject IHttpClientFactory clientFactory
@inject AuthStateProvider auth
@inject NavigationManager nav

<PageTitle>Dung√©Dex : Find</PageTitle>

@if (errorMessage != null)
{
	<p>@errorMessage</p>
}

@if (Dungemon != null)
{
	<h3>@Dungemon.NickName</h3>
	<DungemonDisplay Dungemon=Dungemon DungemonChanged="DungemonChanged"/>
	<div hidden="@(!dungemonBelongsToUser)" id="DeleteDungemon">
		<button @onclick="DeleteDungemonCheck">üóëÔ∏è</button>
		<p>@areYouSure</p>
		<button hidden="@deleteButtonsHidden" @onclick="DeleteDungemon">Yes</button>
		<button hidden="@deleteButtonsHidden" @onclick="Rehide">No</button>
	</div>

	<div hidden="@(string.IsNullOrEmpty(userId) || dungemonBelongsToUser)" id="ForkDungemon">
		<button @onclick="HandleForkRequest">‚ûï Clone This Dung√©mon!</button>
	</div>
}

@code {
	[Parameter]
	public int Id { get; set; }

	private string? userId { get; set; } = null;

	public Dungemon Dungemon { get; set; } = null!;

	private string errorMessage { get; set; } = null!;

	private bool dungemonBelongsToUser = false;

	private string areYouSure = string.Empty;

	private bool deleteButtonsHidden = true;

	protected override async Task OnParametersSetAsync()
	{
		userId = auth.GetUserId();
		try
		{
			using var client = clientFactory.CreateClient("BackendAPI");
			var response = await client.GetAsync($"dungemon/{Id}");
			response.EnsureSuccessStatusCode();
			Dungemon = await response.Content.ReadFromJsonAsync<Dungemon>() ?? throw new Exception();
		}
		catch (HttpRequestException hEx)
		{
			errorMessage = $"There was an issue retrieving data from the Database: {hEx.Message}";
		}
		catch (Exception ex)
		{
			errorMessage = $"There was an issue fetching the Dung√©mon data: {ex.Message}";
		}

		dungemonBelongsToUser = userId == Dungemon.UserId;
	}

	private async Task DungemonChanged(Dungemon updatedDungemon)
	{
		Dungemon = updatedDungemon;
		await HandlePatchRequest();
	}

	private async Task HandlePatchRequest()
	{
		var authState = await auth.GetAuthenticationStateAsync();

		if (authState.User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Sid) == null)
		{
			errorMessage = "You must be signed-in to edit Dung√©mon.";
			return;
		}

		try
		{
			using var client = clientFactory.CreateClient("BackendAPI");
			var response = await client.PatchAsJsonAsync<Dungemon>("dungemon", Dungemon!);
			response.EnsureSuccessStatusCode();
			var patchedDungemon = await response.Content.ReadFromJsonAsync<Dungemon>();

			if (patchedDungemon == null)
			{
				errorMessage = "There was an error updating the Dung√©mon.";
				return;
			}

			Dungemon = patchedDungemon;
		}
		catch (HttpRequestException hex)
		{
			if (hex.StatusCode == HttpStatusCode.Unauthorized) errorMessage = "You must be signed-in to publish Dung√©mon.";

			else errorMessage = hex.Message;
		}
		catch (Exception ex)
		{
			errorMessage = ex.Message;
		}
	}

	private void DeleteDungemonCheck()
	{
		areYouSure = "Are you sure?";
		deleteButtonsHidden = false;
	}

	private void Rehide()
	{
		areYouSure = string.Empty;
		deleteButtonsHidden = true;
	}

	private async Task DeleteDungemon(MouseEventArgs e)
	{
		try
		{
			using var client = clientFactory.CreateClient("BackendAPI");
			var response = await client.DeleteAsync($"dungemon/{Id}");
			response.EnsureSuccessStatusCode();
			areYouSure = "Dung√©mon deleted.";
			await Task.Delay(1000);
			nav.NavigateTo("/");
		}
		catch (HttpRequestException hEx)
		{
			errorMessage = $"There was an issue retrieving data from the Database: {hEx.Message}";
		}
		catch (Exception ex)
		{
			errorMessage = $"There was an issue fetching the Dung√©mon data: {ex.Message}";
		}
	}

	private async Task HandleForkRequest(MouseEventArgs e)
	{
		var userId = auth.GetUserId();

		if (string.IsNullOrEmpty(userId)) return;

		var clone = Dungemon.Clone();
		clone.UserId = userId;
		using var client = clientFactory.CreateClient("BackendAPI");
		var result = await client.PostAsJsonAsync("dungemon", clone);

		if (!result.IsSuccessStatusCode)
		{
			errorMessage = "There was an error attempting to clone the Dung√©mon. Please try again later.";
			return;
		}

		var dungemonResponse = await result.Content.ReadFromJsonAsync<Dungemon>();

		if (dungemonResponse is null)
		{
			errorMessage = "There was an error attempting to clone the Dung√©mon. Please try again later.";
			return;
		}

		dungemonResponse.Spells = Dungemon.Spells.Select(s => s.Clone(dungemonResponse.Id)).ToList();
		dungemonResponse.Actions = Dungemon.Actions.Select(a => a.Clone(dungemonResponse.Id)).ToList();

		var patchResponse = await client.PatchAsJsonAsync("dungemon", dungemonResponse);

		if (!patchResponse.IsSuccessStatusCode)
		{
			errorMessage = "There was an error cloning properties to the new Dung√©mon. Please try again later.";
			return;
		}

		var updatedDungemon = await patchResponse.Content.ReadFromJsonAsync<Dungemon>();

		if (updatedDungemon is null)
		{
			errorMessage = "There was an error cloning properties to the new Dung√©mon. Please try again later.";
			return;
		}

		nav.NavigateTo($"dungemon/{updatedDungemon?.Id}", false);
	}
}
